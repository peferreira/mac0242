options{  IGNORE_CASE = true;  STATIC = false;  LOOKAHEAD= 2; // para eliminar conflitos}// Descrição da classe ParserPARSER_BEGIN(Parser)package parser;import java.util.Vector;import mv.*;import mv.instrucoes.*;import mv.empilhaveis.*;import java.io.FileInputStream;import java.io.FileNotFoundException;public class Parser{  Instrucao [] Prog; // programa  TabSim Nomes = new TabSim(); // nomes globais    int tam = 0; // tamanho do programa}PARSER_END(Parser)// Pula espaço em branco e comentáriosSKIP :{  " "| "\t"| "\n"| "\r"| < "//" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >| < "/*" (~[ "*" ])* "*"    (      "*"    | ~[ "*", "/" ] (~[ "*" ])* "*"    )*    "/" >}// Programa é o ponto de partidaInstrucao [ ] Programa() :{  Vector < Instrucao > p = new Vector < Instrucao > (0); // para retornar  Vector < Instrucao > x = new Vector < Instrucao > (0); // trecho compilado  // por outras regras  Instrucao [ ] a = new Instrucao [ 0 ]; // auxiliar}{  (    x = Comando()    {      p.addAll(x);      tam = p.size();    }  )*  < EOF >  {    p.add(new END()); // para garantir que tem um END    return p.toArray(a);  }}Vector < Instrucao > Comando() :{  Vector < Instrucao > p = new Vector < Instrucao > (0);  Vector < Instrucao > x = new Vector < Instrucao > (0);  Token t;}{  (    x = Expressão() ";"    {      p.addAll(x);    }  | x = Condicional()    {      p.addAll(x);    }  | x = Laço()    {      p.addAll(x);    }  | "print" x = ListPrint()    {      p.addAll(x);    }    ";"  | "println" ";"    {      p.add(new PUSH(new CadeiaDeCaracteres("")));      p.add(new PRN());    }  )  {    return p;  }}// No nível mais baixo calcula as expressões lógicas e realiza as opérações especiaisVector < Instrucao > Expressão() :{  Vector < Instrucao > p = new Vector < Instrucao > (0);  Vector < Instrucao > x = new Vector < Instrucao > (0);}{  x = Arit()  {    p.addAll(x);  }  (    "<=" x = Arit()    {      p.addAll(x);      p.add(new LE());    }  | ">=" x = Arit()    {      p.addAll(x);      p.add(new GE());    }  | "!=" x = Arit()    {      p.addAll(x);      p.add(new NE());    }  | "==" x = Arit()    {      p.addAll(x);      p.add(new EQ());    }  | "<" x = Arit()    {      p.addAll(x);      p.add(new LT());    }  | ">" x = Arit()    {      p.addAll(x);      p.add(new GT());    }  )*  {    return p;  }| "ATTACK" "(" x = Expressão() ")"  {    System.out.println("ataque");    p.addAll(x);    p.add(new ATTACK());    return p;  }| "MOVE" "(" (x = Expressão())? ")"  {    System.out.println("move");    p.addAll(x);    p.add(new MOVE());    return p;  }| "PICK" "(" x = Expressão() ")"  {    System.out.println("pick");    p.addAll(x);    p.add(new PICK());    return p;  }| "DEP" "(" ")"  {    System.out.println("dep");    p.add(new DEP());    p.add(new JIF(new Endereco(2)));    p.add(new POP());    p.add(new PUSH(new CadeiaDeCaracteres("Erro no deposito!")));    p.add(new PRN());    return p;  }| "SCAND"  {    System.out.println("scand");    p.add(new SCAND());    p.add(new DUP());    p.add(new JIF(new Endereco(2)));    p.add(new POP());    return p;  }| "SCANE"  {    System.out.println("scane");    p.add(new SCANE());    p.add(new DUP());    p.add(new JIF(new Endereco(2)));    p.add(new POP());    return p;  }| "SCANC"  {    System.out.println("scanc");    p.add(new SCANC());    p.add(new DUP());    p.add(new JIF(new Endereco(2)));    p.add(new POP());    return p;  }| "HOME"  {    System.out.println("home");    p.add(new HOME());    return p;  }| "WEST"  {    p.add(new PUSH(new WEST()));    return p;  }| "NWEST"  {    p.add(new PUSH(new NWEST()));    return p;  }| "EAST"  {    p.add(new PUSH(new EAST()));    return p;  }| "NEAST"  {    p.add(new PUSH(new NEAST()));    return p;  }| "SWEST"  {    p.add(new PUSH(new SWEST()));    return p;  }| "SEAST"  {    p.add(new PUSH(new SEAST()));    return p;  }| "true"  {    p.add(new PUSH(new Verdadeiro()));    return p;  }| "false"  {    p.add(new PUSH(new Falso()));    return p;  }}// ArtiméticasVector < Instrucao > Arit() :{  Vector < Instrucao > p = new Vector < Instrucao > (0);  Vector < Instrucao > x = new Vector < Instrucao > (0);}{  x = Termo()  {    p.addAll(x);  }  (    "+" x = Termo()    {      p.addAll(x);      p.add(new ADD());    }  | "-" x = Termo()    {      p.addAll(x);      p.add(new SUB());    }  )*  {    return p;  }}Vector < Instrucao > Termo() :{  Vector < Instrucao > p = new Vector < Instrucao > (0);  Vector < Instrucao > x = new Vector < Instrucao > (0);}{  x = Fator()  {    p.addAll(x);  }  (    "*" x = Fator()    {      p.addAll(x);      p.add(new MUL());    }  | "/" x = Fator()    {      p.addAll(x);      p.add(new DIV());    }  )*  {    return p;  }}Vector < Instrucao > Fator() :{  Vector < Instrucao > p = new Vector < Instrucao > (0);  Vector < Instrucao > x = new Vector < Instrucao > (0);  Token t;  Símbolo v;}{  t = < ID > "=" x = Expressão()  {    System.out.println("print1.0");    p.addAll(x);    if (Nomes.exists(t.image))    { // existe como global?      System.out.println("print1");      v = Nomes.get(t.image);      if (v instanceof Variável) p.add(new STO(v.pos));      else p.add(new PRN()); // colocar erro de compilação aqui    }    else    { // cria local ou global, de acordo      v = new Variável();      Nomes.add(t.image, v);      p.add(new STO(v.pos));    }    return p;  }| t = < ID >  { // variável, tratamento similar ao de cima    if (Nomes.exists(t.image))    {      v = Nomes.get(t.image);      if (v instanceof Variável) p.add(new RCL(v.pos));      else p.add(new PRN()); // colocar erro de compilação aqui    }    else    {      // Variável não inicializada      v = new Variável();      Nomes.add(t.image, v);      p.add(new STO(v.pos));    }    return p;  }| t = < NUM >  {    p.add(new PUSH(new Real(Double.parseDouble(t.image))));    return p;  }| "(" x = Expressão() ")"  {    p.addAll(x);    return p;  }}Vector < Instrucao > Condicional() :{  Vector < Instrucao > p = new Vector < Instrucao > (0);  Vector < Instrucao > x = new Vector < Instrucao > (0);  int delta, pos;}{  (    "if"  | "se"  )  "(" x = Expressão()  {    p.addAll(x);  }  ")"  (    "then"  | "então"  )  x = Bloco()  {    delta = x.size();    pos = p.size()+2;    p.add(new PUSH(new Falso()));    p.add(new EQ());    p.add(new JIT(new Endereco(delta + 1)));    p.addAll(x);  }  ( ("else" | "senão" )  x = Bloco()  {    p.set(pos, new JIT(new Endereco(delta + 2)));    delta = x.size();    p.add(new JMP(new Endereco(delta + 1)));    p.addAll(x);  }   )?  {    return p;  } }Vector < Instrucao > Laço() :{  Vector < Instrucao > p = new Vector < Instrucao > (0);  Vector < Instrucao > x = new Vector < Instrucao > (0);  int exp, delta;}{  (    "while"  | "enquanto"  )  "(" x = Expressão()  {    exp = x.size();    p.addAll(x);    System.out.println("expS:" + exp);  }  ")"  (    "do"  | "faça"  )  x = Bloco()  {    delta = x.size();    System.out.println("deltaS:" + delta);    p.add(new PUSH(new Falso()));    p.add(new EQ());    p.add(new JIT(new Endereco(delta + 2)));    p.addAll(x);    p.add(new JMP(new Endereco(- (delta + 3 + exp))));    return p;  }}Vector < Instrucao > Bloco() :{  Vector < Instrucao > p = new Vector < Instrucao > (0);  Vector < Instrucao > x = new Vector < Instrucao > (0);}{  "{"  (    x = Comando()    {      p.addAll(x);    }  )*  "}"  {    return p;  }}// Lista para impressãoVector < Instrucao > ListPrint() :{  Vector < Instrucao > p = new Vector < Instrucao > (0);  Vector < Instrucao > x = new Vector < Instrucao > (0);}{  x = ItemPrint()  {    p.addAll(x);  }  (    "," x = ItemPrint()    {      p.addAll(x);    }  )*  {    return p;  }}// Um ítem a ser impressoVector < Instrucao > ItemPrint() :{  Vector < Instrucao > p = new Vector < Instrucao > (0);  Vector < Instrucao > x = new Vector < Instrucao > (0);  Token t;}{  (    x = Expressão()    {      p.addAll(x);      p.add(new PRN());    }  | t = < STRING_LITERAL >    {      String s = t.image;      while (s.contains("\\n")) s = s.replace("\\n", "\n");      while (s.contains("\\t")) s = s.replace("\\t", "\t");      while (s.contains("\\b")) s = s.replace("\\b", "\b");      while (s.contains("\\r")) s = s.replace("\\r", "\r");      while (s.contains("\\f")) s = s.replace("\\f", "\f");      while (s.contains("\\\\")) s = s.replace("\\\\", "\\");      p.add(new PUSH(new CadeiaDeCaracteres(s.substring(1, s.length() - 1))));      p.add(new PRN());    }  )  {    return p;  }}// Definição dos tokensTOKEN :{  < NUM : ([ "0"-"9" ])+ >| < ID : [ "a"-"z", "A"-"Z", "_" ] ([ "a"-"z", "A"-"Z", "_", "0"-"9", "@" ])* >| < STRING_LITERAL :    "\""    (      ~[ "\"", "\\", "\n", "\r" ]    | "\\"      (        [ "n", "t", "b", "r", "f", "\\", "\'", "\"" ]      | [ "0"-"7" ] ([ "0"-"7" ])?      | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]      |        (          [ "\n", "\r" ]        | "\r\n"        )      )    )*    "\"" >}